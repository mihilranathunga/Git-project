/** Author

 *  Mihil Chathuranga Samarawickrama Ranatunga
 *
 *  Index Number = 100444N
 *
 *  CSE '10
 */

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;

public class IndexReader {                                                      // index searching application

    /**
     * 
     */
    public static void main(String[] args) throws IOException {                 // main method
        // TODO code application logic here

        String[] command;                                                       // additional array for splitting words from a read line
        int page;                                                               // variable for storing page number

        IndexReader in = new IndexReader();                                     // instantiate classes
        Hashtable pages = new Hashtable(1009);                                  // Hashtable for storing page numbers for a given keyword   
        Hashtable keywords = new Hashtable(201);                                // Hashtable for storing keywords for a given page number

        BufferedReader br = in.reader();                                        // initializing buffered reader to read contents from the file

        String line = br.readLine();                                            // read first line

        if (line != null && line.equalsIgnoreCase("Keyword List Start")) {      // check for keyword list start

            while (line != null) {

                line = br.readLine();

                if (line.equalsIgnoreCase("Keyword List End")) {                // stop execution if leyword list ended
                    break;
                }
                command = line.split("\\s+");                                   // split the line to word tokens
                String word = command[0];                                       // keyword
                page = Character.getNumericValue(command[1].charAt(0));         // corresponding page number for the keyword

                pages.insert(word, page);                                       // add values to Hashtables
                keywords.insert(page, word);
            }
        } else {
            System.out.println("Keyword List Start Not Found");                 // if keyword list was not found 
        }

        line = br.readLine();

        if (line != null && line.equalsIgnoreCase("Queries Start")) {           // cheking for querie list start

            while (line != null) {

                line = br.readLine();

                if (line.equalsIgnoreCase("Queries End")) {                     // stop execution if query list ended
                    break;
                }
                command = line.split(" ");                                      // split the read line

                if (command[0].equalsIgnoreCase("First")) {                     // showing first page number for given keyword

                    pages.findPage(command[1]);
                } else if (command[0].equalsIgnoreCase("List")) {               // showing sorted list of page numbers for given keyword

                    pages.findPageList(command[1]);
                } else if (command[0].equalsIgnoreCase("Keywords")) {           // showing sorted list of keywords in a given page number 

                    page = Character.getNumericValue(command[1].charAt(0));
                    keywords.findKeywordList(page);
                } else {                                                        // if query list wasn't found
                    System.out.println("Querie Start Not Found");
                }
            }
        }
    }

    public BufferedReader reader() {                                            // read input file 

        BufferedReader br = null;
        try {
            br = new BufferedReader(new FileReader("Input.txt"));

        } catch (FileNotFoundException ex) {

            System.err.println(ex.getMessage());
            Logger.getLogger(IndexReader.class.getName()).log(Level.SEVERE, null, ex);
        }
        return br;
    }
}

class LinkedList {                       // list for storing duplicate entries of a given keyword or a page number in a hashtable
                                         // list is either a keyword list or a page number list 
    class Link {                         // inner class for individual links in the list

        private int keyPage;             //page number
        private String keyWord;          //keyword
        private Link previous;           //previous Link on the list
        private Link next;               //next Link on the list

        public Link(String keyword) {    //constructor for adding keywords

            keyWord = keyword;
        }

        public Link(int page) {          //overloaded constructor for adding page numberss

            keyPage = page;
        }

        public void displayPage() {      //displays page data in the link

            System.out.print(keyPage + " ");
        }

        public void displayKeyword() {   //displays keyword data in the lint

            System.out.print(keyWord + " ");
        }
    }
    private Link head;                  //ref to the first link
    private Link tail;                  //ref to the last link
    private String key;                 //unique keyword for which the list belongs - identifies list as a keyword list if not null
    private int ListSize;

    public LinkedList(String key) {       //initializing variables - constructor for  hashtable where keyword is the key

        head = null;                        // no data in the list
        tail = null;
        this.key = key;
        ListSize = 0;
    }

    public LinkedList() {                //initializing variables - overloaded constructor for hashtable where page number is the key

        head = null;                    // no data in the list
        tail = null;
        this.key = null;
        ListSize = 0;
    }

    public boolean isEmpty() {          // true if no links 

        if (head == null) {         
            return true;
        } else {
            return false;
        }
    }

    public void displaySize() {         // shows number of links in the list

        System.out.println(ListSize);
    }

    public void addElement(String keyword) {        // inserted data into the already sorted list
                                                    // insert at the end of the list or appropriate position, a keyword link

        Link newLink = new Link(keyword);           // create new link

        if (isEmpty()) {                            // if empty list inserts at head

            head = newLink;                         // head = new link
            tail = newLink;
        } else {                                    // else puts the new value at the end of list or appropriate position
            
            if(tail.keyWord.compareToIgnoreCase(keyword)<=0){   // if tail is lexologically smaller than input keyword
                
                tail.next = newLink;                        // old last --> new link 
                newLink.previous = tail;                    // old last <-- newLink
                tail = newLink;                             // new link == last
            }
            else{                                           // if tail is lexologically larger
                Link current = tail;
                while(current.previous != null && current.keyWord.compareToIgnoreCase(keyword) >1){    /* execute while head is found or
                     *                                                                        a lexologically smaller or equal element
                     *                                                                          in the list is found */
                    current = current.previous;
                }
                if(current.previous == null & current.keyWord.compareToIgnoreCase(keyword) >1){    // if head is found before finding appropriate element                             
                    
                    newLink.next = current;                 // newLink --> Old head            
                    current.previous = newLink;             // newLink <-- Old head
                    head = newLink;                         // newLink == head                
                }else {                                                         //  if a lexologically smaller keyword is found
                    newLink.next = current.next;            // newLink --> next element to small element
                    current.next = newLink;                 // small element --> newLink 
                    newLink.previous = current;             // small element --> newLink     
                }
            }
        }       
        ListSize++;                                 // increment list size
    }

    public void addElement(int page) {              /* overloaded constructor - inserting at the appropriate position
                                                       in ascending order, page number link */
                                                    
        Link newLink = new Link(page);
        if (isEmpty()) {                            // if empty list

            head = newLink;                         // head = new link
            tail = newLink;
        }else{                                    // else puts the new value at the end of list or appropriate position
            
            if(tail.keyPage<=0){   // if tail is lexologically smaller than input keyword
                
                tail.next = newLink;                        // old last --> new link 
                newLink.previous = tail;                    // old last <-- newLink
                tail = newLink;                             // new link == last
            }
            else{                                           // if tail is larger
                Link current = tail;
                while(current.previous != null && current.keyPage >1){    /* execute while head is found or
                     *                                                      a smaller or equal element
                     *                                                      in the list is found */
                    current = current.previous;
                }
                if(current.previous == null & current.keyPage>1){    // if head is found before finding appropriate element                             
                    
                    newLink.next = current;                 // newLink --> Old head            
                    current.previous = newLink;             // newLink <-- Old head
                    head = newLink;                         // newLink == head                
                }else {                                                         //  if a smaller page is found
                    newLink.next = current.next;            // newLink --> next element to small element
                    current.next = newLink;                 // small element --> newLink 
                    newLink.previous = current;             // small element --> newLink     
                }
            }
        }
        ListSize++;                              
    }

    public String getKey() {                        // get's unique keyword value for the list

        return key;
    }

    public void displayFirstKeyword() {             // displays  first and lexologically smallest keyword of the list , list is already sorted

        head.displayKeyword();
        System.out.println();
    }

    public void displayFirstPage() {                // display first and smallest page number in the list

        head.displayPage();
        System.out.println();
    }

    public void displaySortedPageList() {           // list is already sorted, displays page numbers in the list

        Link current = head;

        while (current != null) {

            current.displayPage();
            current = current.next;
        }
        System.out.println();
    }

    public void displaySortedKeyWordList() {    // display keywords list

        Link current = head;
        while (current != null) {

            current.displayKeyword();
            current = current.next;
        }
        System.out.println();
    }
/* This procedure is needed if you need faster data input into the program, so sorting is only executed when data is retrieved from list
     * 
     * Faster data input is hereby assumed not inportant
     
    public void sortList() {                    // sorts the list using insertion sort

        int i = 0;
        Link[] linkArray = new Link[ListSize];  // array of links, size of the listsize 
        Link current = head;

        while (current != null) {               // copies unsorted list to array

            linkArray[i] = current;
            current = current.next;
            i++;
        }
        for (int j = 1; j < ListSize; j++) {                    // insertion sort

            Link keyLink = linkArray[j];
            i = j - 1;
            if (getKey() != null) {                             // do if sorting page numbers

                while (i >= 0 & linkArray[i].keyPage > keyLink.keyPage) { 
                    linkArray[i + 1] = linkArray[i];
                    i = i - 1;
                    if (i < 0) {
                        break;
                    }
                }
            } else {                                             // if sorting keywords 
                while (i >= 0 & linkArray[i].keyWord.compareToIgnoreCase(keyLink.keyWord) > 0) {
                    linkArray[i + 1] = linkArray[i];
                    i = i - 1;
                    if (i < 0) {
                        break;
                    }
                }
            }
            linkArray[i + 1] = keyLink;
        }
        head = null;                                    // clear the current list
        tail = null;
        ListSize = 0;
        for (i = 0; i < linkArray.length; i++) {        // copying the sorted array back to the current list

            if (this.getKey() != (null)) {              // if adding page number links
                addElement(linkArray[i].keyPage);
            } else {                                    // if adding keyword links
                addElement(linkArray[i].keyWord);
            }
        }
    } */
}

class Hashtable {                                       // stores duplicate valuse for given key table is either a keyword hash or a direct access table

    public LinkedList[] hashArray;                      // array of linked lists to store duplicates
    public int arraySize;                               // size of table key space

    Hashtable(int size) {                               // constructor

        arraySize = size;                               // specifies arrays size
        hashArray = new LinkedList[arraySize];          // array definition
    }

    public int hashCode(String keyword) {                   // calculate hashcode for given keyword

        int hashCode = 0;
        String key = keyword.toLowerCase();                 // converts keyword to lowercase
//        if (Character.isLowerCase(key.charAt(0))) {
//
//            hashCode = key.charAt(0) - 96;
//        } else {
//
//            hashCode = key.charAt(0) - 64;
//        }
        for (int i = 0; i < key.length(); i++) {            // hash function - a-z letters are given values 1-26

            hashCode += (key.charAt(i) - 96) * 26 ^ (key.length() - 1);     /* hashcode = (int value)*26^n-1)+(int value)*26^(n-2)......
             *                                                                  n = number of letters in the word  */
        }
        return hashCode;                                    // return hashcode
    }

    public int hashStepFunc(int key) {                      // calculates step value for double hashing, input is hashcode of the specific keyword
                                                        /* non -zero less than array size , array size should be relatively prime to 5,4,3 and 2 */
        return 5 - key % 5;
    }

    public void insert(String keyword, int page) {          // insertes page number in the list shown by hashvalue of the keyword

        int hashCode = hashCode(keyword);                   // hashcode
        int hashValue = hashCode % arraySize;               // hashvalue    ,   to be searched in array
        int stepSize = hashStepFunc(hashCode);              // double hashing if a location is not readily available

        while (hashArray[hashValue] != null && !(hashArray[hashValue].getKey().equalsIgnoreCase(keyword))) {    /* if the postion already filled by another keyword
         *                                                                                                   cheks if it's the same key word or different one */       
            hashValue += stepSize;                          // add the step
            hashValue %= arraySize;                         // for wrap around , if array end is reached start from the top
        }
        if (hashArray[hashValue] == null) {                 // if location shown by hashvalue is empty
            
            hashArray[hashValue] = new LinkedList(keyword); // create linkedlist with unique keyword and initialize slot
        }
        hashArray[hashValue].addElement(page);              // add the page number to the list
    }

    public void insert(int page, String keyword) {          // overloaded function - inserts keywords to the direct access table where location is shown by pagenumber

        if (hashArray[page] == null) {                      // if location is empty
            hashArray[page] = new LinkedList();             // initialize slot
        }
        hashArray[page].addElement(keyword);                // add keyword element
    }

    public void findPage(String keyword) {                  // finds first page of given keyword   

        LinkedList list = find(keyword);                    // get array location then the sorted list of page numbers

        if (list == null) {                                 // if  keyword not found
            System.out.println("Invalid Keyword");
        } else {
            list.displayFirstPage();                        //else
        }
    }

    public void findKeyword(int keyPage) {                  // find fist keyword of givewn page number

        LinkedList list = find(keyPage);                    // get array location threrfore sorted keyword list

        if (list == null) {                                 // if page number not found

            System.out.println("Invalid Page Number");
        } else {
            list.displayFirstPage();                        // display
        }
    }

    public void findPageList(String keyword) {              // display page numbers for the corresponding keyword in sorted order

        LinkedList list = find(keyword);                    // get sorted page number list

        if (list == null) {                                 //if keyword not found
            System.out.println("Invalid Keyword");
        } else {
            list.displaySortedPageList();
        }
    }

    public void findKeywordList(int keyPage) {              // display keywords in sorted order

        LinkedList list = find(keyPage);

        if (list == null) {

            System.out.println("Invalid Page Number");
        } else {
            list.displaySortedKeyWordList();
        }
    }

    public LinkedList find(String keyword) {                /* find hasharray location pointed by hashvalue of given keyword
     *                                                    and get's the linked list in array location , and output already sorted list*/                  
        int hashCode = hashCode(keyword);                   // hashcode
        int hashValue = hashCode % arraySize;               // hashvalue
        int stepSize = hashStepFunc(hashCode);              // sewp size

        while (hashArray[hashValue] != null) {              // executes until non - empty location is pointed by hashvalue 

            if (hashArray[hashValue].getKey().equalsIgnoreCase(keyword)) {  /* break if linked list with matching unique keyword
             *                                                              is found in the pointed array slot */ 
              
                return hashArray[hashValue];                                // return sorted list
            }
            hashValue += stepSize;                                          // add step to hashvalue if correct location is found
            hashValue %= arraySize;                                         // wrap around if necessary, reached the end of array
        }
        return null;                                                        // if matching location is not found
    }

    public LinkedList find(int keyPage) {                  /* find the array location pointed by page number in direct acces table , get's the keyword list
                                                              and output already sorted list */  
        if (hashArray[keyPage] != null) {                   // if location is found


            return hashArray[keyPage];
        } else {                                            // if a location for specified pagenumber is not found
            return null;
        }
    }
}
